require('dotenv').config();
const express = require('express');
const http = require('http');
const cors = require('cors');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
const DatabaseManager = require('./config/database');
const SupabaseAuthHelper = require('./utils/SupabaseAuthHelper');

// Initialize database
const db = new DatabaseManager();

// Initialize auth helper
const authHelper = new SupabaseAuthHelper(db.supabaseAdmin);

// Test database connection on startup
(async () => {
  try {
    const isConnected = await db.testConnection();
    if (isConnected) {
      console.log('âœ… Database connected successfully');
    } else {
      console.error('âŒ Database connection failed');
    }
  } catch (error) {
    console.error('âŒ Database connection error:', error);
  }
})();

const app = express();

// CORS configuration for Supabase
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:5173',
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health check endpoint
app.get('/health', async (req, res) => {
  try {
    const isDbConnected = await db.testConnection();
    res.json({
      status: 'OK',
      timestamp: new Date().toISOString(),
      database: isDbConnected ? 'Connected' : 'Disconnected',
      environment: process.env.NODE_ENV || 'development'
    });
  } catch (error) {
    res.status(500).json({
      status: 'ERROR',
      timestamp: new Date().toISOString(),
      database: 'Error',
      error: error.message
    });
  }
});

// Authentication routes
const authRoutes = require('./routes/auth');
app.use('/api/auth', authRoutes);

// Debug endpoint for token verification (development only)
app.post('/api/debug/verify-token', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(400).json({ 
        error: 'Missing or invalid authorization header',
        expected: 'Authorization: Bearer <token>',
        received: authHeader ? `${authHeader.substring(0, 20)}...` : 'undefined'
      });
    }
    
    const token = authHeader.substring(7);
    
    // Debug token information using Supabase JWT
    let tokenInfo;
    
    try {
      // Decode without verification to inspect token structure
      const decoded = jwt.decode(token, { complete: true });
      
      tokenInfo = {
        header: decoded?.header,
        payload: {
          sub: decoded?.payload?.sub,
          email: decoded?.payload?.email,
          aud: decoded?.payload?.aud,
          exp: decoded?.payload?.exp,
          iat: decoded?.payload?.iat,
          iss: decoded?.payload?.iss,
          role: decoded?.payload?.role
        },
        isExpired: decoded?.payload?.exp ? Date.now() >= decoded.payload.exp * 1000 : false,
        expiresAt: decoded?.payload?.exp ? new Date(decoded.payload.exp * 1000).toISOString() : null
      };
    } catch (decodeError) {
      tokenInfo = { error: 'Failed to decode token: ' + decodeError.message };
    }
    
    // Try to verify the token
    try {
      const user = await getAuthenticatedUser(authHeader);
      res.json({
        success: true,
        user: {
          id: user.id,
          email: user.email,
          name: user.name
        },
        tokenInfo: tokenInfo,
        tokenType: 'Supabase JWT',
        message: 'Token verification successful'
      });
    } catch (verifyError) {
      res.status(401).json({
        success: false,
        error: verifyError.message,
        tokenInfo: tokenInfo,
        tokenType: 'Supabase JWT',
        suggestions: [
          'Check if the token is expired',
          'Ensure you are logged in and have a valid session',
          'Verify that SUPABASE_JWT_SECRET is correctly set in backend',
          'Make sure the token format is correct (should be a Supabase JWT string)',
          'Try logging out and logging back in to get a fresh token',
          'Check if you are using access_token, not refresh_token'
        ]
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Authentication info endpoint
app.get('/api/debug/auth-info', (req, res) => {
  res.json({
    authType: 'Supabase JWT',
    description: 'This application uses Supabase Auth JWT tokens',
    tokenSource: 'Generated by Supabase Auth via /api/auth/login or /api/auth/register endpoints',
    headerFormat: 'Authorization: Bearer <supabase_jwt_token>',
    supabaseConfigured: {
      url: !!process.env.SUPABASE_URL,
      anonKey: !!process.env.SUPABASE_ANON_KEY,
      serviceKey: !!process.env.SUPABASE_SERVICE_KEY,
      jwtSecret: !!process.env.SUPABASE_JWT_SECRET
    },
    customJwtConfigured: !!process.env.JWT_SECRET,
    endpoints: {
      login: 'POST /api/auth/login',
      register: 'POST /api/auth/register',
      profile: 'GET /api/auth/profile',
      debugToken: 'POST /api/debug/verify-token'
    }
  });
});

// Debug endpoint for testing RLS permissions
app.post('/api/debug/test-rls', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(400).json({ 
        error: 'Missing or invalid authorization header',
        expected: 'Authorization: Bearer <token>'
      });
    }
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(authHeader);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    const testResults = {
      user: {
        id: authenticatedUser.id,
        email: authenticatedUser.email,
        name: authenticatedUser.name
      },
      timestamp: new Date().toISOString(),
      tests: {}
    };
    
    // Test 1: Can read own question sets
    try {
      const { data: ownSets, error: ownSetsError } = await db.supabaseAdmin
        .from('question_sets')
        .select('id, title, user_id')
        .eq('user_id', authenticatedUser.id)
        .limit(5);
      
      testResults.tests.readOwnQuestionSets = {
        success: !ownSetsError,
        count: ownSets?.length || 0,
        error: ownSetsError?.message
      };
    } catch (error) {
      testResults.tests.readOwnQuestionSets = {
        success: false,
        error: error.message
      };
    }
    
    // Test 2: Can read public question sets
    try {
      const { data: publicSets, error: publicSetsError } = await db.supabaseAdmin
        .from('question_sets')
        .select('id, title, is_public')
        .eq('is_public', true)
        .limit(5);
      
      testResults.tests.readPublicQuestionSets = {
        success: !publicSetsError,
        count: publicSets?.length || 0,
        error: publicSetsError?.message
      };
    } catch (error) {
      testResults.tests.readPublicQuestionSets = {
        success: false,
        error: error.message
      };
    }
    
    // Test 3: Try to create a test question set
    try {
      const { data: testSet, error: createError } = await db.supabaseAdmin
        .from('question_sets')
        .insert({
          user_id: authenticatedUser.id,
          title: 'RLS Test Question Set',
          description: 'Testing RLS policies',
          category: 'test',
          is_public: false,
          total_questions: 0
        })
        .select()
        .single();
      
      testResults.tests.createQuestionSet = {
        success: !createError,
        questionSetId: testSet?.id,
        error: createError?.message
      };
      
      // Clean up test data
      if (testSet?.id) {
        await db.supabaseAdmin
          .from('question_sets')
          .delete()
          .eq('id', testSet.id);
      }
    } catch (error) {
      testResults.tests.createQuestionSet = {
        success: false,
        error: error.message
      };
    }
    
    // Test 4: Database connection and service role
    try {
      const { data: dbTest, error: dbError } = await db.supabaseAdmin
        .from('users')
        .select('count', { count: 'exact', head: true });
      
      testResults.tests.databaseConnection = {
        success: !dbError,
        serviceRole: true,
        error: dbError?.message
      };
    } catch (error) {
      testResults.tests.databaseConnection = {
        success: false,
        serviceRole: false,
        error: error.message
      };
    }
    
    res.json(testResults);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// API routes for question sets
app.get('/api/question-sets/public', async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;
    
    // For now, return a simple test question set if database is empty
    const result = await db.getPublicQuestionSets(parseInt(limit), parseInt(offset));
    
    if (result.success && result.questionSets.length > 0) {
      res.json({ questionSets: result.questionSets });
    } else {
      // Return a default question set for testing
      const defaultQuestionSet = {
        id: 'default-questions',
        title: 'ã‚µãƒ³ãƒ—ãƒ«ã‚¯ã‚¤ã‚º',
        description: 'åŸºæœ¬çš„ãªæ—¥æœ¬ã®çŸ¥è­˜ã‚¯ã‚¤ã‚º',
        category: 'general',
        difficulty_level: 'medium',
        total_questions: 5,
        is_public: true,
        created_at: new Date().toISOString()
      };
      res.json({ questionSets: [defaultQuestionSet] });
    }
  } catch (error) {
    console.error('Error fetching question sets:', error);
    // Return default question set on error
    const defaultQuestionSet = {
      id: 'default-questions',
      title: 'ã‚µãƒ³ãƒ—ãƒ«ã‚¯ã‚¤ã‚º',
      description: 'åŸºæœ¬çš„ãªæ—¥æœ¬ã®çŸ¥è­˜ã‚¯ã‚¤ã‚º',
      category: 'general',
      difficulty_level: 'medium',
      total_questions: 5,
      is_public: true,
      created_at: new Date().toISOString()
    };
    res.json({ questionSets: [defaultQuestionSet] });
  }
});

// API endpoint to get user's own question sets (must be before :id route)
app.get('/api/question-sets/my-sets', async (req, res) => {
  try {
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    const { limit = 20, offset = 0 } = req.query;
    
    // Get user's question sets
    const { data: questionSets, error } = await db.supabaseAdmin
      .from('question_sets')
      .select('*')
      .eq('user_id', authenticatedUser.id)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);
    
    if (error) {
      return res.status(500).json({ error: error.message });
    }
    
    res.json({ questionSets: questionSets || [] });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/question-sets/:id', async (req, res) => {
  try {
    const result = await db.getQuestionSetWithQuestions(req.params.id);
    
    if (result.success) {
      res.json({ questionSet: result.questionSet });
    } else {
      res.status(404).json({ error: result.error });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Additional API endpoints for testing
// Question Set Routes - Step by step approach

// Helper function to get authenticated user from token
const getAuthenticatedUser = async (authHeader) => {
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new Error('Missing or invalid authorization header. Expected format: "Bearer <token>"');
  }
  
  const token = authHeader.substring(7);
  
  // Validate token is not empty or undefined
  if (!token || token === 'undefined' || token === 'null' || token.trim() === '') {
    throw new Error('Invalid token: Token is empty, undefined, or null');
  }
  
  console.log('ðŸ” Verifying Supabase JWT token:', token.substring(0, 20) + '...');
  console.log('ðŸ” Token length:', token.length);
  
  try {
    // Use Supabase admin client to verify the token
    const { data: { user }, error } = await db.supabaseAdmin.auth.getUser(token);
    
    if (error) {
      console.error('âŒ Supabase token verification error:', error);
      
      if (error.message.includes('invalid_token') || error.message.includes('jwt')) {
        throw new Error('Invalid JWT token format or signature. Please check if you are sending the correct access_token.');
      }
      if (error.message.includes('expired')) {
        throw new Error('Token has expired. Please log in again to get a new token.');
      }
      if (error.message.includes('malformed')) {
        throw new Error('Malformed JWT token. Please check the token format.');
      }
      
      throw new Error('Token verification failed: ' + error.message);
    }
    
    if (!user) {
      throw new Error('No user found for this token. The token may be invalid or the user may have been deleted.');
    }
    
    console.log('âœ… Supabase token verified for user:', user.id, user.email);
    
    // Get user profile from database using adminClient to bypass RLS
    const { data: userProfile, error: profileError } = await db.supabaseAdmin
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (profileError) {
      console.error('âŒ Profile fetch error:', profileError);
      
      // If user profile doesn't exist, create it
      if (profileError.code === 'PGRST116') { // No rows returned
        console.log('ðŸ†• Creating user profile for:', user.email);
        const { data: newProfile, error: createError } = await db.supabaseAdmin
          .from('users')
          .insert({
            id: user.id,
            email: user.email,
            name: user.user_metadata?.name || user.user_metadata?.full_name || user.email?.split('@')[0] || 'User'
          })
          .select()
          .single();
        
        if (createError) {
          console.error('âŒ Failed to create user profile:', createError);
          throw new Error('Failed to create user profile: ' + createError.message);
        }
        
        console.log('âœ… User profile created:', newProfile.name, newProfile.email);
        return newProfile;
      } else {
        throw new Error('User profile fetch failed: ' + profileError.message);
      }
    }
    
    if (!userProfile) {
      throw new Error('User profile not found in database');
    }
    
    console.log('âœ… User profile found:', userProfile.name, userProfile.email);
    return userProfile;
    
  } catch (error) {
    console.error('âŒ Authentication error details:', error);
    throw error;
  }
};

// Step 1: Create question set metadata only
app.post('/api/question-sets/metadata', async (req, res) => {
  try {
    console.log('Creating question set metadata:', req.body);
    
    const { title, description, category, difficulty_level, is_public, estimated_duration } = req.body;
    
    // Validate required fields
    if (!title?.trim()) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
      console.log('Authenticated user:', authenticatedUser.id, authenticatedUser.name);
    } catch (authError) {
      console.error('Authentication error:', authError.message);
      return res.status(401).json({ error: authError.message });
    }
    
    // Create question set metadata using authenticated user
    const { data: questionSet, error } = await db.supabaseAdmin
      .from('question_sets')
      .insert({
        user_id: authenticatedUser.id,
        title: title.trim(),
        description: description?.trim() || '',
        category: category || 'general',
        difficulty_level: difficulty_level || 'medium',
        is_public: is_public || false,
        estimated_duration: estimated_duration || 5,
        total_questions: 0
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error creating question set:', error);
      return res.status(500).json({ error: error.message });
    }
    
    console.log('Question set metadata created:', questionSet.id, 'by user:', authenticatedUser.name);
    res.json(questionSet);
  } catch (error) {
    console.error('Error in question set metadata creation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Step 2: Create individual question
app.post('/api/questions', async (req, res) => {
  try {
    console.log('Creating question:', req.body);
    
    const { 
      question_set_id, 
      question_text, 
      question_type, 
      time_limit, 
      points, 
      difficulty, 
      order_index, 
      explanation 
    } = req.body;
    
    // Validate required fields
    if (!question_set_id || !question_text?.trim()) {
      return res.status(400).json({ error: 'Question set ID and question text are required' });
    }
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    // Verify that the question set belongs to the authenticated user
    const { data: questionSet, error: questionSetError } = await db.supabaseAdmin
      .from('question_sets')
      .select('user_id')
      .eq('id', question_set_id)
      .eq('user_id', authenticatedUser.id)
      .single();
    
    if (questionSetError || !questionSet) {
      return res.status(403).json({ error: 'Question set not found or unauthorized' });
    }
    
    // Create question
    const { data: question, error } = await db.supabaseAdmin
      .from('questions')
      .insert({
        question_set_id,
        question_text: question_text.trim(),
        question_type: question_type || 'multiple_choice',
        time_limit: time_limit || 10,
        points: points || 1000,
        difficulty: difficulty || 'medium',
        order_index: order_index || 0,
        explanation: explanation || ''
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error creating question:', error);
      return res.status(500).json({ error: error.message });
    }
    
    console.log('Question created:', question.id, 'by user:', authenticatedUser.name);
    res.json(question);
  } catch (error) {
    console.error('Error in question creation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Step 3: Create individual answer
app.post('/api/answers', async (req, res) => {
  try {
    console.log('Creating answer:', req.body);
    
    const { question_id, answer_text, is_correct, order_index } = req.body;
    
    // Validate required fields
    if (!question_id || !answer_text?.trim()) {
      return res.status(400).json({ error: 'Question ID and answer text are required' });
    }
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    // Verify that the question belongs to a question set owned by the authenticated user
    const { data: questionOwnership, error: ownershipError } = await db.supabaseAdmin
      .from('questions')
      .select(`
        id,
        question_sets!inner(
          user_id
        )
      `)
      .eq('id', question_id)
      .eq('question_sets.user_id', authenticatedUser.id)
      .single();
    
    if (ownershipError || !questionOwnership) {
      return res.status(403).json({ error: 'Question not found or unauthorized' });
    }
    
    // Create answer
    const { data: answer, error } = await db.supabaseAdmin
      .from('answers')
      .insert({
        question_id,
        answer_text: answer_text.trim(),
        is_correct: is_correct || false,
        order_index: order_index || 0
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error creating answer:', error);
      return res.status(500).json({ error: error.message });
    }
    
    console.log('Answer created:', answer.id, 'by user:', authenticatedUser.name);
    res.json(answer);
  } catch (error) {
    console.error('Error in answer creation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Step 4: Finalize question set (update total questions)
app.patch('/api/question-sets/:id/finalize', async (req, res) => {
  try {
    const { id } = req.params;
    const { total_questions, settings } = req.body;
    
    console.log(`Finalizing question set ${id} with ${total_questions} questions`);
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    // Verify ownership of the question set
    const { data: questionSet, error: verifyError } = await db.supabaseAdmin
      .from('question_sets')
      .select('user_id')
      .eq('id', id)
      .eq('user_id', authenticatedUser.id)
      .single();
    
    if (verifyError || !questionSet) {
      return res.status(403).json({ error: 'Question set not found or unauthorized' });
    }
    
    // Update question set with final metadata
    const { data: updatedQuestionSet, error } = await db.supabaseAdmin
      .from('question_sets')
      .update({
        total_questions: total_questions || 0,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();
    
    if (error) {
      console.error('Error finalizing question set:', error);
      return res.status(500).json({ error: error.message });
    }
    
    console.log('Question set finalized:', updatedQuestionSet.id, 'by user:', authenticatedUser.name);
    res.json(updatedQuestionSet);
  } catch (error) {
    console.error('Error in question set finalization:', error);
    res.status(500).json({ error: error.message });
  }
});

// Original bulk question set creation (keep for backward compatibility)
app.post('/api/question-sets', async (req, res) => {
  try {
    const { 
      title, 
      description, 
      category, 
      difficulty_level, 
      is_public,
      estimated_duration,
      questions 
    } = req.body;
    
    // Get authenticated user
    let authenticatedUser;
    try {
      authenticatedUser = await getAuthenticatedUser(req.headers.authorization);
      console.log('Creating question set for authenticated user:', authenticatedUser.id, authenticatedUser.name);
    } catch (authError) {
      return res.status(401).json({ error: authError.message });
    }
    
    const questionSetData = {
      title,
      description: description || '',
      category: category || 'general',
      difficulty_level: difficulty_level || 'medium',
      is_public: is_public !== false, // Default to true for testing
      estimated_duration: estimated_duration || 10,
      user_id: authenticatedUser.id, // Use the authenticated user ID
      total_questions: questions ? questions.length : 0
    };
    
    console.log('Creating question set with data:', questionSetData);
    console.log('Questions:', questions?.length || 0, 'questions');
    
    const result = await db.createQuestionSet(questionSetData, questions || []);
    
    if (result.success) {
      res.status(201).json({ questionSet: result.questionSet });
    } else {
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/games/:gameCode', async (req, res) => {
  try {
    const result = await db.getGameByCode(req.params.gameCode);
    
    if (result.success) {
      res.json({ game: result.game });
    } else {
      res.status(404).json({ error: result.error });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

const server = http.createServer(app);

// Socket.IO server with enhanced CORS
const io = new Server(server, {
    cors: {
        origin: process.env.SOCKET_CORS_ORIGIN || 'http://localhost:5173',
        methods: ['GET', 'POST'],
        credentials: true
    },
});

// Store active games in memory (you could also use Redis for production)
const activeGames = new Map();

io.on('connection', (socket) => {
  console.log(`ðŸ”Œ New user connected: ${socket.id}`);

  // Create a new game
  socket.on('createGame', async ({ hostId, questionSetId, settings }) => {
    try {
      console.log(`ðŸŽ® Create Game Request:
      Host ID: ${hostId}
      Settings: ${JSON.stringify(settings)}`);
      
      // Generate a simple game code for now
      const gameCode = Math.floor(100000 + Math.random() * 900000).toString();
      
      // Create a simple game object without database dependency for now
      const game = {
        id: gameCode,
        game_code: gameCode,
        host_id: hostId,
        status: 'waiting',
        players_cap: settings?.maxPlayers || 50,
        current_players: 0,
        game_settings: settings || {},
        created_at: new Date().toISOString()
      };
      
      // Store game in memory for quick access
      activeGames.set(gameCode, {
        ...game,
        hostSocket: socket.id,
        players: new Map(),
        questions: require('./data/questions.json').questions // Load questions from JSON
      });
      
      socket.join(gameCode);
      socket.emit('gameCreated', { 
        game: game,
        gameCode 
      });
      
      console.log(`âœ… Game created with code: ${gameCode}`);
    } catch (error) {
      console.error('âŒ Create game error:', error);
      socket.emit('error', { message: error.message });
    }
  });

  // Join a game
  socket.on('joinGame', async ({ playerName, gameCode, userId = null }) => {
    try {
      console.log(`ðŸŽ® Join Game Request:
      Game Code: ${gameCode}
      Player Name: ${playerName}
      Socket ID: ${socket.id}`);
      
      // Get game from memory
      const activeGame = activeGames.get(gameCode);
      
      if (!activeGame) {
        socket.emit('error', { message: 'Game not found' });
        return;
      }
      
      if (activeGame.status !== 'waiting') {
        socket.emit('error', { message: 'Game has already started' });
        return;
      }
      
      if (activeGame.players.size >= activeGame.players_cap) {
        socket.emit('error', { message: 'Game is full' });
        return;
      }
      
      // Create player object
      const player = {
        id: socket.id,
        user_id: userId,
        name: playerName,
        score: 0,
        joined_at: new Date().toISOString(),
        socketId: socket.id
      };
      
      // Add player to game
      activeGame.players.set(socket.id, player);
      activeGame.current_players = activeGame.players.size;
      
      socket.join(gameCode);
      
      // Notify player
      socket.emit('gameJoined', { 
        game: activeGame,
        player: player 
      });
      
      // Notify all players in the game
      io.to(gameCode).emit('playerJoined', {
        player: player,
        totalPlayers: activeGame.players.size
      });
      
      console.log(`âœ… Player ${playerName} joined game ${gameCode}`);
    } catch (error) {
      console.error('âŒ Join game error:', error);
      socket.emit('error', { message: error.message });
    }
  });

  // Start game
  socket.on('startGame', async ({ gameCode }) => {
    try {
      console.log(`ðŸš€ Start Game Request: ${gameCode}`);
      
      const activeGame = activeGames.get(gameCode);
      if (!activeGame || activeGame.hostSocket !== socket.id) {
        socket.emit('error', { message: 'Unauthorized or game not found' });
        return;
      }
      
      // Update game status
      activeGame.status = 'active';
      activeGame.started_at = new Date().toISOString();
      activeGame.currentQuestionIndex = 0;
      
      // Notify all players that the game has started
      io.to(gameCode).emit('gameStarted', {
        game: activeGame,
        message: 'Game is starting!'
      });
      
      console.log(`âœ… Game ${gameCode} started with ${activeGame.players.size} players`);
    } catch (error) {
      console.error('âŒ Start game error:', error);
      socket.emit('error', { message: error.message });
    }
  });

  // Submit answer
  socket.on('submitAnswer', async ({ gameCode, questionId, answerId, responseTime }) => {
    try {
      const activeGame = activeGames.get(gameCode);
      if (!activeGame) {
        socket.emit('error', { message: 'Game not found' });
        return;
      }
      
      const player = activeGame.players.get(socket.id);
      if (!player) {
        socket.emit('error', { message: 'Player not found in game' });
        return;
      }
      
      // Submit answer to database
      const answerData = {
        game_id: activeGame.id,
        player_id: player.player_id,
        question_id: questionId,
        answer_id: answerId,
        response_time: responseTime,
        points_earned: 0, // Calculate based on correctness and time
        is_correct: false // Will be updated based on answer validation
      };
      
      const result = await db.submitPlayerAnswer(answerData);
      
      if (result.success) {
        socket.emit('answerSubmitted', {
          success: true,
          points: result.answer.points_earned
        });
        
        console.log(`âœ… Answer submitted by ${player.player_name}`);
      } else {
        socket.emit('error', { message: result.error });
      }
    } catch (error) {
      console.error('âŒ Submit answer error:', error);
      socket.emit('error', { message: error.message });
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log(`ðŸ”Œ User disconnected: ${socket.id}`);
    
    // Remove player from active games
    for (const [gameCode, game] of activeGames.entries()) {
      if (game.players.has(socket.id)) {
        const player = game.players.get(socket.id);
        game.players.delete(socket.id);
        
        // Notify other players
        socket.to(gameCode).emit('playerLeft', {
          player: player,
          totalPlayers: game.players.size
        });
        
        console.log(`ðŸ‘‹ Player ${player.player_name} left game ${gameCode}`);
        break;
      }
      
      // If host disconnects, you might want to handle game cleanup
      if (game.hostSocket === socket.id) {
        console.log(`ðŸ  Host disconnected from game ${gameCode}`);
        // You could pause the game or transfer host rights
      }
    }
  });
});

const PORT = 3001;
const HOST = '0.0.0.0'; // Listen on all network interfaces
server.listen(PORT, HOST, () => {
    console.log(`ðŸš€ Server is running on ${HOST}:${PORT}`);
    console.log(`ðŸ“± Mobile access: Use your computer's local IP address (e.g., 192.168.1.xxx:${PORT})`);
    console.log(`ðŸ’» Local access: http://localhost:${PORT}`);
});

